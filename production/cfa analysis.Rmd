---
title: 'cfa analýsis'
author: "Daniel Miranda, Julio Iturra, Brian Montenegro & Karen Sepúlveda"
date: "13-01-2021"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(lavaan, # pacman para instalar / cargar 
               psych, # para funcion lowerMat
               Hmisc, # rcorr
               stargazer,
               xtable,
               semPlot,
               semTools,
               remedy
               )

```


```{r message=FALSE, warning=FALSE, cache=FALSE, include=FALSE, results="asis"}
#Desactivar notaci?n cient?fica
options(scipen=999)
pacman::p_load(dplyr, texreg, xtable, stargazer, # Reporte a latex
sjPlot, sjmisc, # reporte y gráficos
skimr,
corrplot, # grafico correlaciones
xtable, # Reporte a latex
Hmisc, # varias funciones
psych, # fa y principal factors
psy, # scree plot function
nFactors, # parallel
GPArotation, devtools, CTT, lavaan, semTable, GGally, QuantPsyc) 
```


# Análisis factorial confirmatorio con __lavaan__

## Conceptos 

_Especificación del modelo_: expresar las hipótesis como un set de ecuaciones. Así, el objetivo de la técnica es reproducir la matriz de varianzas/covarianzas a partir de los parámetros especificados

- Matriz de varianzas/covarianzas = factores comúnes + elementos únicos

- Matriz de  varianzas/covarianzas ($\Sigma$) = cargas factoriales ($\Lambda$) + correlación entre factores ($\Psi$) +  error ($\Theta$)

- $\Sigma= \Lambda_{y} \Psi \Lambda' + \Theta_{\varepsilon}$ 


_Identificación del modelo_:  depende de la ecuación de elementos conocidos - elementos desconocidos.

$$ = (p*(p+1))/2$$

_Estimación_: procedimiento por medio del cual se obtiene una estimación para cada parámetro que permite producir una matriz de varianza-covarianza $\Sigma$ que se asemeje lo más posible a la matriz de original($S$). Por tanto, el objetivo es $\Sigma = S$.


_Ajuste_:¿que tan bueno es el modelo? o ¿que tan cerca está $\Sigma$ de $S$?. Para esto ha propuesto una serie de indicadores de ajuste: absolutos y relativos.

 - Test de $\chi^{2}$: Mayor valor, peor ajuste.
 
 - Comparative Fit Index-CFI: Compara el modelo con un modelo nulo. Valores sobre 0,95 son considerados aceptables
 
 $CFI=1-\frac{d_{modelo}}{d_{modelo nulo}}$, donde: $d=(\chi^{2}- df)$
 
 - Root Mean Square Error of Aproximation-RMSEA= Corrige por parsimonia. Valores menores a 0,05 se consideran adecuados.
 
 $RMSEA= \sqrt{\frac{\frac{\chi^{2}}{df}-1}{N-1}}$


## Pasos a seguir

- Especificación
- Identificación
- Estimación
- Ajuste

### a. Especificación del modelo
```{r }
cfa_1 <- '
# latent variables
formal =~ int_inf + int_pre + int_mun
nodisrruptivo =~ par_fir + par_servcom + par_reupol + par_marau
disrruptivo =~ par_marnoau + par_toma + par_bloq + par_pared
'
```


### b. Estimación del modelo
```{r }
fit_1 <- cfa(cfa_1,data, ordered=c("par_fir","par_marau","par_marnoau","par_toma","par_bloq", "par_pared", "par_servcom", "par_reupol","int_mun","int_pre","int_inf"))
```


La estimación arroja una serie de informaciones, tales como ajuste, parámetros estimados, medidas estandarizadas, posibles modificaciones, entre otros. En esta práctica nos centraremos solo en ajuste general y solución estandarizada.

Función *show*: muestra la medida de ajuste de $\chi^2$ del modelo, junto con los grados de libertad

```{r }
show(fit_1) # Resumen ajuste general
fitMeasures(fit_1, c("chisq", "df", "pvalue", "cfi", "tli", "rmsea"))
```

Con esta información se espera no rechazar la hipótesis nula, es decir, que el test no sea estadísticamente significativo, ya que implicaría que la matriz de varianzas-covarianzas y la matriz implicada en el modelo no difieren significativamente.

Respecto del cálculo de los grados de libertad del modelo, recordar que equivalen a elementos conocidos - elementos desconocidos o a estimar, lo cual se relaciona con la identificación del modelo.

Conocidos: $p(p+1)/2 = 7*8/2 = 28 $

Desconocidos: 7 cargas factoriales + 7 varianzas únicas = 14.
Por lo tanto, 28-14=14 df.


### Diagrama con función _semPaths_ de la librería _semPlot_
```{r }

	#semPaths(fitsem, title = FALSE, fixedStyle = c(1, 1), curvePivot = FALSE,layout = "tree2", rotation=2, style="mx")
	#semPaths(fitsem, title = FALSE, fixedStyle = c(1, 1),  curvePivot = FALSE,layout = "tree2", rotation=2, style="lisrel")
	#semPaths(fitsem, rotation=3, what="std", structural=FALSE, exoVar=TRUE, color="red", layout = "tree", residuals=TRUE, intercepts=FALSE)
  semPaths(fit_1, rotation=3, what="std", whatLabels="cons", style="lisrel", exoCov = T, curvePivot = TRUE, sizeMan = 5, sizeInt = 7, 
     residuals=T)

  semPaths(fit_1, rotation=3, whatLabels="std", style="lisrel", exoCov = T, curvePivot = TRUE, sizeMan = 5, sizeInt = 7)
  
  semPaths(fitsem, rotation=3, whatLabels="std", style="lisrel", exoCov = T, curvePivot = T, sizeMan = 8, sizeLat = 15, 
     residuals=T)
  
  semPaths(fit_1, style="lisrel", curvePivot = TRUE,
        whatLabels = "std", edge.label.cex = .9, node.label.cex = 1.5, 
        label.prop=0.9, edge.label.color = "black", rotation = 4, 
        equalizeManifests = TRUE, optimizeLatRes = TRUE, node.width = 1.5, 
        edge.width = 0.5, shapeMan = "rectangle", shapeLat = "ellipse", 
        shapeInt = "triangle", sizeMan = 5, sizeInt = 3, sizeLat = 15, 
        curve=3, unCol = "#070b8c")
  
  semPaths(fit_1, style="lisrel", what="std", curvePivot = TRUE,
        whatLabels = "std", edge.label.cex = .9, node.label.cex = 1.5, 
        label.prop=0.9, edge.label.color = "black", rotation = 4, 
        equalizeManifests = TRUE, optimizeLatRes = TRUE, node.width = 1.5, 
        edge.width = 0.5, shapeMan = "rectangle", shapeLat = "ellipse", 
        shapeInt = "triangle", sizeMan = 5, sizeInt = 3, sizeLat = 15, 
        curve=3)
	
```


### Diagrama con función _semPaths_ de la librería _semPlot_
```{r }

 semPaths(fit_1, style="lisrel", what="std", curvePivot = TRUE,
        whatLabels = "std", edge.label.cex = .9, node.label.cex = 1.5, 
        label.prop=0.9, edge.label.color = "black", rotation = 4, 
        equalizeManifests = TRUE, optimizeLatRes = TRUE, node.width = 1.5, 
        edge.width = 0.5, shapeMan = "rectangle", shapeLat = "ellipse", 
        shapeInt = "triangle", sizeMan = 5, sizeInt = 3, sizeLat = 15, 
        curve=3)
```


```{r}
data2 <- data %>% select("folio", "par_fir","par_marau","par_marnoau","par_toma","par_bloq", "par_pared", "par_servcom", "par_reupol","int_mun","int_pre","int_inf") %>% na.omit()

predict <- predict(fit_1)

scores = as.data.frame(predict)

data2 = bind_cols(data2, scores)

data3 = data2 %>% select(folio, formal, nodisrruptivo, disrruptivo)

data = left_join(x = data, y=data3, by="folio")

names(data)
```